diff -Naur netgen-5.3.1_SRC_orig/libsrc/meshing/findip.hpp netgen-5.3.1_SRC_modif/libsrc/meshing/findip.hpp
--- netgen-5.3.1_SRC_orig/libsrc/meshing/findip.hpp	2014-08-29 13:54:05.000000000 +0400
+++ netgen-5.3.1_SRC_modif/libsrc/meshing/findip.hpp	2017-09-11 18:08:21.226312730 +0300
@@ -75,6 +75,9 @@
   static int timer = NgProfiler::CreateTimer ("FindInnerPoint");
   NgProfiler::RegionTimer reg (timer);
 
+  if ( points.Size() < 3 )
+    return 0;
+
   Array<Vec3d> a;
   Array<double> c;
   Mat<3> m, inv;
diff -Naur netgen-5.3.1_SRC_orig/libsrc/meshing/improve3.cpp netgen-5.3.1_SRC_modif/libsrc/meshing/improve3.cpp
--- netgen-5.3.1_SRC_orig/libsrc/meshing/improve3.cpp	2014-08-29 13:54:05.000000000 +0400
+++ netgen-5.3.1_SRC_modif/libsrc/meshing/improve3.cpp	2017-09-11 18:08:21.227312622 +0300
@@ -1219,6 +1219,7 @@
 
 	      tetused = 0;
 	      tetused[0] = 1;
+              int nbtetused = 0;
 
 	      for (int l = 2; l < nsuround; l++)
 		{
@@ -1239,10 +1240,12 @@
 			      
 			      tetused[k] = 1; 
 			      suroundpts[l] = newpi;
+                              ++nbtetused;
 			    }			
 		      }
 		}
-
+              if ( nbtetused < nsuround )
+                continue;
 	      
 	      bad1 = 0;
 	      for (int k = 0; k < nsuround; k++)
diff -Naur netgen-5.3.1_SRC_orig/libsrc/occ/occgenmesh.cpp netgen-5.3.1_SRC_modif/libsrc/occ/occgenmesh.cpp
--- netgen-5.3.1_SRC_orig/libsrc/occ/occgenmesh.cpp	2014-08-29 13:54:03.000000000 +0400
+++ netgen-5.3.1_SRC_modif/libsrc/occ/occgenmesh.cpp	2017-09-11 18:08:21.231312190 +0300
@@ -171,8 +171,8 @@
          if(h < 1e-4*maxside)
             return;
 
-
-         if (h > 30) return;
+         // commented to restrict H on a large sphere for example
+         //if (h > 30) return;
       }
 
       if (h < maxside && depth < 10)
@@ -259,9 +259,13 @@
       {
          oldpnt = pnt;
          pnt = c->Value(s0+(i/double(DIVIDEEDGESECTIONS))*(s1-s0));
+         // -- no more than 1 segment per <edge length>/DIVIDEEDGESECTIONS
          hvalue[i] = hvalue[i-1] +
+         //   1.0/mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z()))*
+         //   pnt.Distance(oldpnt);
+           min( 1.0,
             1.0/mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z()))*
-            pnt.Distance(oldpnt);
+                pnt.Distance(oldpnt));
 
          //(*testout) << "mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z())) " << mesh.GetH(Point3d(pnt.X(), pnt.Y(), pnt.Z()))
          //	   <<  " pnt.Distance(oldpnt) " << pnt.Distance(oldpnt) << endl;
@@ -282,7 +286,10 @@
       {
          if (hvalue[i1]/hvalue[DIVIDEEDGESECTIONS]*nsubedges >= i)
          {
-            params[i] = s0+(i1/double(DIVIDEEDGESECTIONS))*(s1-s0);
+            // -- for nsubedges comparable to DIVIDEEDGESECTIONS
+            //params[i] = s0+(i1/double(DIVIDEEDGESECTIONS))*(s1-s0);
+            double d1 = i1 - (hvalue[i1] - i*hvalue[DIVIDEEDGESECTIONS]/nsubedges)/(hvalue[i1]-hvalue[i1-1]);
+            params[i] = s0+(d1/double(DIVIDEEDGESECTIONS))*(s1-s0);
             pnt = c->Value(params[i]);
             ps[i-1] = MeshPoint (Point3d(pnt.X(), pnt.Y(), pnt.Z()));
             i++;
@@ -326,6 +333,9 @@
       (*testout) << "nedges = " << nedges << endl;
 
       double eps = 1e-6 * geom.GetBoundingBox().Diam();
+      const double eps2 = eps * eps; // -- small optimization
+
+      int first_vp = mesh.GetNP()+1; // -- to support SALOME sub-meshes
 
       for (int i = 1; i <= nvertices; i++)
       {
@@ -335,7 +345,8 @@
          bool exists = 0;
          if (merge_solids)
             for (PointIndex pi = 1; pi <= mesh.GetNP(); pi++)
-               if ( Dist2 (mesh[pi], Point<3>(mp)) < eps*eps)
+               //if ( Dist2 (mesh[pi], Point<3>(mp)) < eps*eps)              
+               if ( Dist2 (mesh[pi], Point<3>(mp)) < eps2 ) // -- small optimization
                {
                   exists = 1;
                   break;
@@ -365,6 +376,7 @@
          {
             TopoDS_Face face = TopoDS::Face(exp1.Current());
             int facenr = geom.fmap.FindIndex(face);
+            if ( facenr < 1 ) continue; // -- to support SALOME sub-meshes
 
             if (face2solid[0][facenr-1] == 0)
                face2solid[0][facenr-1] = solidnr;
@@ -384,6 +396,7 @@
       int facenr = 0;
       int edgenr = 0;
 
+      edgenr = mesh.GetNSeg(); // to support SALOME sub-meshes
 
       (*testout) << "faces = " << geom.fmap.Extent() << endl;
       int curr = 0;
@@ -445,6 +458,7 @@
                   //(*testout) << "ignoring degenerated edge" << endl;
                   continue;
                }
+               if ( geom.emap.FindIndex(edge) < 1 ) continue; // to support SALOME sub-meshes
 
                if (geom.vmap.FindIndex(TopExp::FirstVertex (edge)) ==
                   geom.vmap.FindIndex(TopExp::LastVertex (edge)))
@@ -477,20 +491,104 @@
 
                if (!merge_solids)
                {
-                  pnums[0] = geom.vmap.FindIndex (TopExp::FirstVertex (edge));
-                  pnums[pnums.Size()-1] = geom.vmap.FindIndex (TopExp::LastVertex (edge));
+                 //pnums[0] = geom.vmap.FindIndex (TopExp::FirstVertex (edge));
+                 //pnums[pnums.Size()-1] = geom.vmap.FindIndex (TopExp::LastVertex (edge));
+                 MeshPoint dfltP ( Point<3> ( 0, 0, 0 ) );
+                 int *ipp[] = { &pnums[0], &pnums[pnums.Size()-1] };
+                 TopoDS_Iterator vIt( edge, false );
+                 TopoDS_Vertex v[2];
+                 v[0] = TopoDS::Vertex( vIt.Value() ); vIt.Next();
+                 v[1] = TopoDS::Vertex( vIt.Value() );
+                 if ( v[0].Orientation() == TopAbs_REVERSED )
+                   std::swap( v[0], v[1] );
+                 for ( int i = 0; i < 2; ++i)
+                 {
+                   int &ip = *ipp[i];
+                   ip = geom.vmap.FindIndex ( v[i] );
+                   if ( ip == 0 || ip > nvertices )
+                   {
+                     int iv = ip;
+                     if ( ip == 0 )
+                       ip = iv = geom.vmap.Add( v[i] );
+                     gp_Pnt pnt = BRep_Tool::Pnt( v[i] );
+                     MeshPoint mp( Point<3>(pnt.X(), pnt.Y(), pnt.Z()) );
+                     for (PointIndex pi = 1; pi < first_vp; pi++)
+                       if ( Dist2 (mesh.Point(pi), Point<3>(mp)) < 1e-100 )
+                       {
+                         ip = pi;
+                         if ( mesh.Point(ip).GetLayer() != dfltP.GetLayer() && mesh.Point(ip).GetLayer() != iv )
+                           continue;
+                         if ( mesh.Point(ip).GetLayer() == dfltP.GetLayer())
+                           mesh.Point(ip) = MeshPoint( mesh.Point(ip), iv );
+                         break;
+                       }
                }
                else
                {
-                  Point<3> fp = occ2ng (BRep_Tool::Pnt (TopExp::FirstVertex (edge)));
-                  Point<3> lp = occ2ng (BRep_Tool::Pnt (TopExp::LastVertex (edge)));
+                     ip += first_vp - 1;
+                   }
+                 }
+               }
+               else
+               {
+                 TopoDS_Iterator vIt( edge, false );
+                 TopoDS_Vertex v1 = TopoDS::Vertex( vIt.Value() ); vIt.Next();
+                 TopoDS_Vertex v2 = TopoDS::Vertex( vIt.Value() );
+                 if ( v1.Orientation() == TopAbs_REVERSED )
+                   std::swap( v1, v2 );
+                 const bool isClosedEdge = v1.IsSame( v2 );
+                 
+                  Point<3> fp = occ2ng (BRep_Tool::Pnt (v1));
+                  Point<3> lp = occ2ng (BRep_Tool::Pnt (v2));
+                  double tol2 = std::min( eps*eps, 1e-6 * Dist2( fp, lp ));
+                  if ( isClosedEdge )
+                    tol2 = BRep_Tool::Tolerance( v1 ) * BRep_Tool::Tolerance( v1 );
 
                   pnums[0] = -1;
                   pnums.Last() = -1;
                   for (PointIndex pi = 1; pi < first_ep; pi++)
                   {
-                     if (Dist2 (mesh[pi], fp) < eps*eps) pnums[0] = pi;
-                     if (Dist2 (mesh[pi], lp) < eps*eps) pnums.Last() = pi;
+                    if (Dist2 (mesh[pi], fp) < tol2) pnums[0] = pi;
+                    if (Dist2 (mesh[pi], lp) < tol2) pnums.Last() = pi;
+                  }
+                  if (( isClosedEdge && pnums[0] != pnums.Last() ) ||
+                      ( !isClosedEdge && pnums[0] == pnums.Last() ))
+                    pnums[0] = pnums.Last() = -1;
+                  if ( pnums[0] == -1 || pnums.Last() == -1 )
+                  {
+                    // take into account a possible large gap between a vertex and an edge curve
+                    // end and a large vertex tolerance covering the whole edge
+                    if ( pnums[0] == -1 )
+                    {
+                      double tol = BRep_Tool::Tolerance( v1 );
+                      for (PointIndex pi = 1; pi < first_ep; pi++)
+                        if (pi != pnums.Last() && Dist2 (mesh[pi], fp) < 2*tol*tol)
+                          pnums[0] = pi;
+
+                      if ( pnums[0] == -1 )
+                        pnums[0] = first_ep-1- nvertices + geom.vmap.FindIndex ( v1 );
+                    }
+                    if ( isClosedEdge )
+                    {
+                      pnums.Last() = pnums[0];
+                    }
+                    else
+                    {
+                      if ( pnums.Last() == -1 )
+                      {
+                        double tol = BRep_Tool::Tolerance( v2 );
+                        for (PointIndex pi = 1; pi < first_ep; pi++)
+                          if (pi != pnums[0] && Dist2 (mesh[pi], lp) < 2*tol*tol)
+                            pnums.Last() = pi;
+
+                        if ( pnums.Last() == -1 )
+                          pnums.Last() = first_ep-1-nvertices + geom.vmap.FindIndex ( v2 );
+                      }
+
+                      if ( Dist2( fp, mesh[PointIndex(pnums[0])]) >
+                           Dist2( lp, mesh[PointIndex(pnums.Last())]))
+                      std::swap( pnums[0], pnums.Last() );
+                    }
                   }
                }
 
@@ -500,17 +598,20 @@
                   bool exists = 0;
                   int j;
                   for (j = first_ep; j <= mesh.GetNP(); j++)
+                  {
+                     if (!merge_solids && mesh.Point(j).GetLayer() != geomedgenr ) continue; // to support SALOME fuse edges
                      if ((mesh.Point(j)-Point<3>(mp[i-1])).Length() < eps)
                      {
                         exists = 1;
                         break;
                      }
+                  }
 
                      if (exists)
                         pnums[i] = j;
                      else
                      {
-                        mesh.AddPoint (mp[i-1]);
+                        mesh.AddPoint (mp[i-1], geomedgenr); // to support SALOME fuse edges
                         (*testout) << "add meshpoint " << mp[i-1] << endl;
                         pnums[i] = mesh.GetNP();
                      }
@@ -594,6 +695,8 @@
       //		(*testout) << "edge " << mesh.LineSegment(i).edgenr << " face " << mesh.LineSegment(i).si
       //				<< " p1 " << mesh.LineSegment(i)[0] << " p2 " << mesh.LineSegment(i)[1] << endl;
       //	exit(10);
+      for (int j = 1; j <= mesh.GetNP(); j++) // to support SALOME fuse edges: set level to zero
+        mesh.Point(j) = MeshPoint( (Point<3>&) mesh.Point(j) );
 
       mesh.CalcSurfacesOfNode();
       multithread.task = savetask;
diff -Naur netgen-5.3.1_SRC_orig/libsrc/occ/occgeom.cpp netgen-5.3.1_SRC_modif/libsrc/occ/occgeom.cpp
--- netgen-5.3.1_SRC_orig/libsrc/occ/occgeom.cpp	2014-08-29 13:54:03.000000000 +0400
+++ netgen-5.3.1_SRC_modif/libsrc/occ/occgeom.cpp	2017-09-11 18:08:32.836058020 +0300
@@ -8,6 +8,8 @@
 #include "ShapeAnalysis_CheckSmallFace.hxx"
 #include "ShapeAnalysis_DataMapOfShapeListOfReal.hxx"
 #include "ShapeAnalysis_Surface.hxx"
+#include <BRepTopAdaptor_FClass2d.hxx> // -- to optimize Project() and FastProject()
+#include <TopAbs_State.hxx>
 
 #include "BRepCheck_Analyzer.hxx"
 #include "BRepLib.hxx"
@@ -29,6 +31,14 @@
 
 namespace netgen
 {
+  // free data used to optimize Project() and FastProject()
+  OCCGeometry::~OCCGeometry()
+  {
+    NCollection_DataMap<int,BRepTopAdaptor_FClass2d*>::Iterator it(fclsmap);
+    for (; it.More(); it.Next())
+      delete it.Value();
+  }
+
    void OCCGeometry :: PrintNrShapes ()
    {
       TopExp_Explorer e;
@@ -951,25 +960,58 @@
    }
 
 
+   // returns a projector and a classifier for the given surface
+   void OCCGeometry::GetFaceTools(int surfi, Handle(ShapeAnalysis_Surface)& proj,
+                                  BRepTopAdaptor_FClass2d*& cls) const
+   {
+     //MSV: organize caching projector in the map
+     if (fprjmap.IsBound(surfi))
+     {
+       proj = fprjmap.Find(surfi);
+       cls = fclsmap.Find(surfi);
+     }
+     else
+     {
+       const TopoDS_Face& aFace = TopoDS::Face(fmap(surfi));
+       Handle(Geom_Surface) aSurf = BRep_Tool::Surface(aFace);
+       proj = new ShapeAnalysis_Surface(aSurf);
+       fprjmap.Bind(surfi, proj);
+       cls = new BRepTopAdaptor_FClass2d(aFace,Precision::Confusion());
+       fclsmap.Bind(surfi, cls);
+     }
+   }
 
-
-   void OCCGeometry :: Project (int surfi, Point<3> & p) const
+   // void OCCGeometry :: Project (int surfi, Point<3> & p) const
+   bool OCCGeometry :: Project (int surfi, Point<3> & p, double& u, double& v) const
    {
       static int cnt = 0;
       if (++cnt % 1000 == 0) cout << "Project cnt = " << cnt << endl;
 
       gp_Pnt pnt(p(0), p(1), p(2));
 
-      double u,v;
-      Handle( Geom_Surface ) thesurf = BRep_Tool::Surface(TopoDS::Face(fmap(surfi)));
-      Handle( ShapeAnalysis_Surface ) su = new ShapeAnalysis_Surface( thesurf );
-      gp_Pnt2d suval = su->ValueOfUV ( pnt, BRep_Tool::Tolerance( TopoDS::Face(fmap(surfi)) ) );
-      suval.Coord( u, v);
-      pnt = thesurf->Value( u, v );
-
+      // -- Optimization: use cached projector and classifier
+      // double u,v;
+      // Handle( Geom_Surface ) thesurf = BRep_Tool::Surface(TopoDS::Face(fmap(surfi)));
+      // Handle( ShapeAnalysis_Surface ) su = new ShapeAnalysis_Surface( thesurf );
+      // gp_Pnt2d suval = su->ValueOfUV ( pnt, BRep_Tool::Tolerance( TopoDS::Face(fmap(surfi)) ) );
+      // suval.Coord( u, v);
+      // pnt = thesurf->Value( u, v );  
+
+      Handle(ShapeAnalysis_Surface) proj;
+      BRepTopAdaptor_FClass2d *cls;
+      GetFaceTools(surfi, proj, cls);
+
+      gp_Pnt2d p2d = proj->ValueOfUV(pnt, Precision::Confusion());
+      if (cls->Perform(p2d) == TopAbs_OUT)
+      {
+        return false;
+      }
+      pnt = proj->Value(p2d);
+      p2d.Coord(u, v);
 
       p = Point<3> (pnt.X(), pnt.Y(), pnt.Z());
 
+      return true;
    }
 
 
@@ -991,54 +1033,69 @@
    {
       gp_Pnt p(ap(0), ap(1), ap(2));
 
-      Handle(Geom_Surface) surface = BRep_Tool::Surface(TopoDS::Face(fmap(surfi)));
-
-      gp_Pnt x = surface->Value (u,v);
-
-      if (p.SquareDistance(x) <= sqr(PROJECTION_TOLERANCE)) return true;
-
-      gp_Vec du, dv;
-
-      surface->D1(u,v,x,du,dv);
-
-      int count = 0;
-
-      gp_Pnt xold;
-      gp_Vec n;
-      double det, lambda, mu;
-
-      do {
-         count++;
-
-         n = du^dv;
-
-         det = Det3 (n.X(), du.X(), dv.X(),
-            n.Y(), du.Y(), dv.Y(),
-            n.Z(), du.Z(), dv.Z());
-
-         if (det < 1e-15) return false;
-
-         lambda = Det3 (n.X(), p.X()-x.X(), dv.X(),
-            n.Y(), p.Y()-x.Y(), dv.Y(),
-            n.Z(), p.Z()-x.Z(), dv.Z())/det;
-
-         mu     = Det3 (n.X(), du.X(), p.X()-x.X(),
-            n.Y(), du.Y(), p.Y()-x.Y(),
-            n.Z(), du.Z(), p.Z()-x.Z())/det;
-
-         u += lambda;
-         v += mu;
-
-         xold = x;
-         surface->D1(u,v,x,du,dv);
-
-      } while (xold.SquareDistance(x) > sqr(PROJECTION_TOLERANCE) && count < 50);
-
-      //    (*testout) << "FastProject count: " << count << endl;
-
-      if (count == 50) return false;
-
-      ap = Point<3> (x.X(), x.Y(), x.Z());
+      // -- Optimization: use cached projector and classifier
+      // Handle(Geom_Surface) surface = BRep_Tool::Surface(TopoDS::Face(fmap(surfi)));
+      // 
+      // gp_Pnt x = surface->Value (u,v);
+      // 
+      // if (p.SquareDistance(x) <= sqr(PROJECTION_TOLERANCE)) return true;
+      // 
+      // gp_Vec du, dv;
+      // 
+      // surface->D1(u,v,x,du,dv);
+      // 
+      // int count = 0;
+      // 
+      // gp_Pnt xold;
+      // gp_Vec n;
+      // double det, lambda, mu;
+      // 
+      // do {
+      //    count++;
+      // 
+      //    n = du^dv;
+      // 
+      //    det = Det3 (n.X(), du.X(), dv.X(),
+      //       n.Y(), du.Y(), dv.Y(),
+      //       n.Z(), du.Z(), dv.Z());
+      // 
+      //    if (det < 1e-15) return false;
+      // 
+      //    lambda = Det3 (n.X(), p.X()-x.X(), dv.X(),
+      //       n.Y(), p.Y()-x.Y(), dv.Y(),
+      //       n.Z(), p.Z()-x.Z(), dv.Z())/det;
+      // 
+      //    mu     = Det3 (n.X(), du.X(), p.X()-x.X(),
+      //       n.Y(), du.Y(), p.Y()-x.Y(),
+      //       n.Z(), du.Z(), p.Z()-x.Z())/det;
+      // 
+      //    u += lambda;
+      //    v += mu;
+      // 
+      //    xold = x;
+      //    surface->D1(u,v,x,du,dv);
+      // 
+      // } while (xold.SquareDistance(x) > sqr(PROJECTION_TOLERANCE) && count < 50);
+      // 
+      // //    (*testout) << "FastProject count: " << count << endl;
+      // 
+      // if (count == 50) return false;
+      // 
+      // ap = Point<3> (x.X(), x.Y(), x.Z());
+      Handle(ShapeAnalysis_Surface) proj;
+      BRepTopAdaptor_FClass2d *cls;
+      GetFaceTools(surfi, proj, cls);
+
+      gp_Pnt2d p2d = proj->NextValueOfUV(gp_Pnt2d(u,v), p, Precision::Confusion());
+      if (cls->Perform(p2d) == TopAbs_OUT)
+      {
+        //cout << "Projection fails" << endl;
+        return false;
+      }
+
+      p = proj->Value(p2d);
+      p2d.Coord(u, v);
+      ap = Point<3> (p.X(), p.Y(), p.Z());
 
       return true;
    }
diff -Naur netgen-5.3.1_SRC_orig/libsrc/occ/occgeom.hpp netgen-5.3.1_SRC_modif/libsrc/occ/occgeom.hpp
--- netgen-5.3.1_SRC_orig/libsrc/occ/occgeom.hpp	2014-08-29 13:54:03.000000000 +0400
+++ netgen-5.3.1_SRC_modif/libsrc/occ/occgeom.hpp	2017-09-11 18:08:21.233311974 +0300
@@ -15,8 +15,8 @@
 #include "Geom_Curve.hxx"
 #include "Geom2d_Curve.hxx"
 #include "Geom_Surface.hxx"
-#include "GeomAPI_ProjectPointOnSurf.hxx"
-#include "GeomAPI_ProjectPointOnCurve.hxx"
+// #include "GeomAPI_ProjectPointOnSurf.hxx"
+// #include "GeomAPI_ProjectPointOnCurve.hxx"
 #include "BRepTools.hxx"
 #include "TopExp.hxx"
 #include "BRepBuilderAPI_MakeVertex.hxx"
@@ -42,8 +42,8 @@
 #include "Geom_Curve.hxx"
 #include "Geom2d_Curve.hxx"
 #include "Geom_Surface.hxx"
-#include "GeomAPI_ProjectPointOnSurf.hxx"
-#include "GeomAPI_ProjectPointOnCurve.hxx"
+// #include "GeomAPI_ProjectPointOnSurf.hxx"
+// #include "GeomAPI_ProjectPointOnCurve.hxx"
 #include "TopoDS_Wire.hxx"
 #include "BRepTools_WireExplorer.hxx"
 #include "BRepTools.hxx"
@@ -68,18 +68,26 @@
 #include "IGESToBRep_Reader.hxx"
 #include "Interface_Static.hxx"
 #include "GeomAPI_ExtremaCurveCurve.hxx"
-#include "Standard_ErrorHandler.hxx"
+//#include "Standard_ErrorHandler.hxx"
 #include "Standard_Failure.hxx"
 #include "ShapeUpgrade_ShellSewing.hxx"
 #include "ShapeFix_Shape.hxx"
 #include "ShapeFix_Wireframe.hxx"
+#include <Standard_Version.hxx>
+#if (OCC_VERSION_MAJOR << 16 | OCC_VERSION_MINOR << 8 | OCC_VERSION_MAINTENANCE) <= 0x060702
+// porting to OCCT6.7.3
 #include "BRepMesh.hxx"
+#endif
 #include "BRepMesh_IncrementalMesh.hxx"
 #include "BRepBndLib.hxx"
 #include "Bnd_Box.hxx"
 #include "ShapeAnalysis.hxx"
 #include "ShapeBuild_ReShape.hxx"
 
+// -- Optimization: to use cached projector and classifier
+#include <NCollection_DataMap.hxx>
+class ShapeAnalysis_Surface;
+class BRepTopAdaptor_FClass2d;
 
 // Philippose - 29/01/2009
 // OpenCascade XDE Support
@@ -192,6 +200,9 @@
    class OCCGeometry : public NetgenGeometry
    {
       Point<3> center;
+      // -- Optimization: to use cached projector and classifier
+      mutable NCollection_DataMap<int,Handle(ShapeAnalysis_Surface)> fprjmap;
+      mutable NCollection_DataMap<int,BRepTopAdaptor_FClass2d*> fclsmap;
 
    public:
       TopoDS_Shape shape;
@@ -247,6 +258,8 @@
      virtual void Save (string filename) const;
 
 
+      ~OCCGeometry();      // -- to free cached projector and classifier
+
       void BuildFMap();
 
       Box<3> GetBoundingBox()
@@ -266,9 +279,14 @@
       Point<3> Center()
       {  return center;}
 
-      void Project (int surfi, Point<3> & p) const;
+      // void Project (int surfi, Point<3> & p) const; -- optimization
+      bool Project (int surfi, Point<3> & p, double& u, double& v) const;
       bool FastProject (int surfi, Point<3> & ap, double& u, double& v) const;
 
+      // -- Optimization: to use cached projector and classifier
+      void GetFaceTools(int surfi, Handle(ShapeAnalysis_Surface)& proj,
+                        BRepTopAdaptor_FClass2d*& cls) const;
+
       OCCSurface GetSurface (int surfi)
       {
          cout << "OCCGeometry::GetSurface using PLANESPACE" << endl;
diff -Naur netgen-5.3.1_SRC_orig/libsrc/occ/occmeshsurf.cpp netgen-5.3.1_SRC_modif/libsrc/occ/occmeshsurf.cpp
--- netgen-5.3.1_SRC_orig/libsrc/occ/occmeshsurf.cpp	2014-08-29 13:54:03.000000000 +0400
+++ netgen-5.3.1_SRC_modif/libsrc/occ/occmeshsurf.cpp	2017-09-11 18:08:21.233311974 +0300
@@ -6,6 +6,7 @@
 #include <meshing.hpp>
 #include <GeomLProp_SLProps.hxx>
 #include <ShapeAnalysis_Surface.hxx>
+#include <GeomAPI_ProjectPointOnCurve.hxx> // -- moved here from occgeom.hpp
 
 
 namespace netgen
@@ -96,13 +97,16 @@
 
 	n.Normalize();
       }
-    else
+    else if ( lprop.IsNormalDefined() )
       {
 	n(0)=lprop.Normal().X();
 	n(1)=lprop.Normal().Y();
 	n(2)=lprop.Normal().Z();
       }
-
+    else
+      {
+        n = 0;
+      }
     if(glob_testout)
       {
 	(*testout) << "u " << geominfo.u << " v " << geominfo.v 
@@ -434,23 +438,33 @@
 
   void MeshOptimize2dOCCSurfaces :: ProjectPoint (INDEX surfind, Point<3> & p) const
   {
-    geometry.Project (surfind, p);
+    // geometry.Project (surfind, p); -- signature of Project() changed for optimization
+    double u, v;
+    geometry.Project (surfind, p, u, v);
   }
 
 
   int MeshOptimize2dOCCSurfaces :: ProjectPointGI (INDEX surfind, Point<3> & p, PointGeomInfo & gi) const
   {
-    double u = gi.u;
-    double v = gi.v;
+    //double u = gi.u;
+    //double v = gi.v;
 
     Point<3> hp = p;
-    if (geometry.FastProject (surfind, hp, u, v))
-      {
+    // -- u and v are computed by FastProject() and Project(), no need to call CalcPointGeomInfo()
+    // if (geometry.FastProject (surfind, hp, u, v))
+    //   {
+    //    p = hp;
+    //    return 1;
+    //   }
+    // ProjectPoint (surfind, p); 
+    // return CalcPointGeomInfo (surfind, gi, p); 
+    bool ok;
+    if (gi.trignum > 0)
+      ok = geometry.FastProject (surfind, hp, gi.u, gi.v);
+    else
+      ok = geometry.Project (surfind, hp, gi.u, gi.v);
 	p = hp;
-	return 1;
-      }
-    ProjectPoint (surfind, p); 
-    return CalcPointGeomInfo (surfind, gi, p); 
+    return ok;
   }
 
 
@@ -680,7 +694,8 @@
 	if (!geometry.FastProject (surfi, hnewp, u, v))
 	  {
 	  //  cout << "Fast projection to surface fails! Using OCC projection" << endl;
-	    geometry.Project (surfi, hnewp);
+	    // geometry.Project (surfi, hnewp); -- Project() changed for optimization
+	    geometry.Project (surfi, hnewp, u, v);
 	  }
 
 	newgi.trignum = 1;
@@ -713,7 +728,11 @@
   void OCCRefinementSurfaces :: ProjectToSurface (Point<3> & p, int surfi) const
   {
     if (surfi > 0)
-      geometry.Project (surfi, p);
+      //geometry.Project (surfi, p);
+    {
+      double u, v;
+      geometry.Project (surfi, p, u, v);
+    }
   }
 
   void OCCRefinementSurfaces :: ProjectToSurface (Point<3> & p, int surfi, PointGeomInfo & gi) const
@@ -723,7 +741,8 @@
       if (!geometry.FastProject (surfi, p, gi.u, gi.v))
 	{
 	  cout << "Fast projection to surface fails! Using OCC projection" << endl;
-	  geometry.Project (surfi, p);
+          double u, v;
+	  geometry.Project (surfi, p, u, v);
 	}
   }
 
